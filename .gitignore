# Risk modelling in R -- learing by doing 
# (c) Matthias Greiner, BfR/TiHo 2013

# Simple probabilistic model to assess the risk and benefit of purchasing a koi carp
# See course script for further details (in German).

# Number of iterationen. Global variable assessible in other functions
it	<-	10000

# Expressing uncertainty about a Bernoulli/binomial parameter using a beta distribution
# Assume empirical data in form of estimator k/n
k	<-	10				
n	<-	1000				
P	<-	rbeta(it, k+1, n-k+1)				

# Display the created variable P			
summary(P)
hist(P)			

# Define function to generate a Monte Carlo (MC) sample from a beta distribution given empirical (k, n) 
myBeta <- function(k,n)
  {
  rbeta(it, k+1, n-k+1)
  }

# Define function to characterise a data set (summary statitsics, histogram and kernel density)
myRes	<-	function(data)
  {
  sum <- summary(data)
  print(sum)
  hist(data,prob=TRUE,xlab=deparse(substitute(data)),main="")
  lines(density(data),col="blue")
}

# Further model input
# Diagnostic sensitivity (Se) of the test, assume empirical data Se=10/10 
Se	<-	myBeta(10,10)
myRes(Se)				

# Diagnostic specificity (Sp) of the test, assume certainty about Sp=1 
Sp	<-	1

# Assume financial loss (L) in EUR associated with introducing an infected fish (utility of false negativen test result)
L <- 250

# Assume financial gain (G) in EUR associated with introducing  non-infected fish (utility of true negative test result)
G <- 80

# Expected loss (EL) due to an infected, undiagnosed fish 
EL	<- 	P*(1-Se)*L				

# Expected gain (EG) due to a non-infected, correctly diagnosed fish 
EG	<-	(1-P)*Sp*G				

# Expected gain minus loss (estimation under uncertainty)
GML <- 	EG-EL				

# Breakeven point (BE) for prevalence (where EG = EL)
# Obtained by equating EG and EL and solving for P
# Evaluation under uncertainty results in a distribution for BE
BE	<-	1/(((1-Se)*L/(Sp*G))+1)				

# Have a look at the results
myRes(EG)
myRes(EL)
myRes(GML)
myRes(BE)


# Breakeven contour for Se and P ranging [0,1] and Sp=1
# Blue area: OK to introduce the fish
# The contour plot is generated from a grid matrix containing difference values
gp <- 100 # number of gridpoints
grid <- matrix(nrow=gp,ncol=gp)
Sensitivity <- seq(0, 1, length.out=gp)
Prevalence <- seq(0, 1, length.out=gp)
for(i in 1:gp){
  grid[i,] <- (1-Prevalence)*G - Prevalence*(1-Sensitivity[i])*L
  }

# The indifference contour (Difference=0) should be white colour. Therefore, we change 
# just one grid point such that abs(min(grid))=abs(max(grid)).
grid[1,1] <- -min(grid)
filled.contour2(grid,xlab = "Sensitivity", ylab = "Prevalence",
  main = "Gain minus loss",
  color.palette=colorRampPalette(c("red", "white", "blue")),
  nlevels=100)

# And we add labelled countour lines 
contour(grid, add=TRUE)

# In fact, the filled.contour command from the graphics package does not seem to allow
# removing the key from the contour plot. Therefore, we have used the modified version
# filled.contour2 as described at http://wiki.cbr.washington.edu/qerm/index.php/R/Contour_Plots
# which is copied here:


filled.contour2 <-
  function (x = seq(0, 1, length.out = nrow(z)),
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), 
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), 
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, 
            col = color.palette(length(levels) - 1), plot.title, plot.axes, 
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, 
            axes = TRUE, frame.plot = axes,mar, ...) 
{
  # modification by Ian Taylor of the filled.contour function
  # to remove the key and facilitate overplotting with contour()
  if (missing(z)) {
    if (!missing(x)) {
      if (is.list(x)) {
        z <- x$z
        y <- x$y
        x <- x$x
      }
      else {
        z <- x
        x <- seq.int(0, 1, length.out = nrow(z))
      }
    }
    else stop("no 'z' matrix specified")
  }
  else if (is.list(x)) {
    y <- x$y
    x <- x$x
  }
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) 
    stop("increasing 'x' and 'y' values expected")
  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
  on.exit(par(par.orig))
  w <- (3 + mar.orig[2]) * par("csi") * 2.54
  par(las = las)
  mar <- mar.orig
  plot.new()
  par(mar=mar)
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) 
    stop("no proper 'z' matrix specified")
  if (!is.double(z)) 
    storage.mode(z) <- "double"
  .Internal(filledcontour(as.double(x), as.double(y), z, as.double(levels), 
                          col = col))
  if (missing(plot.axes)) {
    if (axes) {
      title(main = "", xlab = "", ylab = "")
      Axis(x, side = 1)
      Axis(y, side = 2)
    }
  }
  else plot.axes
  if (frame.plot) 
    box()
  if (missing(plot.title)) 
    title(...)
  else plot.title
  invisible()
}
